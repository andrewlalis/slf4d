/** 
 * The handler module defines the `LogHandler` interface, as well as several
 * simple handler implementations that can be used or extended by SLF4D
 * providers.
 */
module slf4d.handler;

import slf4d.logger;
import slf4d.level;

/** 
 * The interface for any component that consumes log messages generated by a
 * `Logger`. Only messages whose level is greater than or equal to the logger's
 * level will be sent to handlers. For example, a Logger configured at an INFO
 * log level will send INFO, WARN, and ERROR messages, but not DEBUG or TRACE.
 *
 * Each Logger has a single root LogHandler instance. This "root handler" can
 * be a very simple handler that sends messages to stdout, or it could be a
 * more complex composition of handlers to distribute logs to various locations
 * according to filtering logic.
 *
 * Note that the handler is `shared`. One handler instance exists and is used
 * by all application threads.
 */
shared interface LogHandler {
    /** 
     * Handles a log message.
     * Params:
     *   msg = The log message that was generated.
     */
    shared void handle(LogMessage msg);
}

/** 
 * A log handler that discards all messages. Useful for testing.
 */
class DiscardingLogHandler : LogHandler {
    shared void handle(LogMessage msg) {
        // Do nothing.
    }
}

/** 
 * A log handler that simply appends all messages it receives to an internal
 * array. This can be useful for testing.
 */
class CachingLogHandler : LogHandler {
    public shared LogMessage[] messages;

    public shared void handle(LogMessage msg) {
        this.messages ~= msg;
    }

    public shared void reset() {
        this.messages = [];
    }
}

unittest {
    auto handler = new shared CachingLogHandler();
    Logger logger = Logger(handler);
    assert(handler.messages.length == 0);
    logger.info("Hello world!");
    assert(handler.messages.length == 1);
}

/** 
 * A very primitive log handler that writes messages to stdout. The exact
 * format is undefined, and this handler should **not** be used in production
 * applications.
 */
class StdoutLogHandler : LogHandler {
    import std.stdio;

    shared void handle(LogMessage msg) {
        writefln!"[logger=%s, module=%s, func=%s level=%s] %s: %s"(
            msg.loggerName,
            msg.sourceContext.moduleName,
            msg.sourceContext.functionName,
            msg.level.name,
            msg.timestamp.toISOExtString(),
            msg.message
        );
    }
}

/** 
 * A log handler that simply passes any log message it receives to a list of
 * other handlers.
 */
class MultiLogHandler : LogHandler {
    private shared LogHandler[] handlers;

    public shared this(shared LogHandler[] handlers) {
        this.handlers = handlers;
    }

    shared void handle(LogMessage msg) {
        foreach (handler; handlers) {
            handler.handle(msg);
        }
    }
}

unittest {
    auto h1 = new shared CachingLogHandler();
    auto h2 = new shared CachingLogHandler();
    auto multiHandler = new shared MultiLogHandler([h1, h2]);
    Logger logger = Logger(multiHandler);
    logger.info("Hello world!");
    assert(h1.messages.length == 1);
    assert(h2.messages.length == 1);
}

/** 
 * A handler that applies a filter to log messages, and only passes messages to
 * its internal handler if the filter returns `true`.
 */
class FilterLogHandler : LogHandler {
    private bool function (LogMessage) filterFunction;
    private shared LogHandler handler;

    public shared this(shared LogHandler handler, bool function (LogMessage) filterFunction) {
        this.handler = handler;
        this.filterFunction = filterFunction;
    }

    shared void handle(LogMessage msg) {
        if (this.filterFunction(msg)) {
            this.handler.handle(msg);
        }
    }
}

unittest {
    auto baseHandler = new shared CachingLogHandler();
    auto filterHandler = new shared FilterLogHandler(
        baseHandler,
        (msg) {
            return msg.message.length > 10;
        }
    );
    Logger logger = Logger(filterHandler);
    logger.info("Testing");
    assert(baseHandler.messages.length == 0);
    logger.info("This is a long string!");
    assert(baseHandler.messages.length == 1);
}

/** 
 * A handler that sends log messages to different handlers depending on the
 * level of the message.
 */
class LevelMappedLogHandler : LogHandler {
    public static struct LevelRange {
        public const int minLevel;
        public const int maxLevel;
    }

    private static struct Mapping {
        public const LevelRange range;
        public shared LogHandler handler;
    }

    private Mapping[] mappings;

    public void addMapping(Level level, shared LogHandler handler) {
        this.mappings ~= Mapping(
            LevelRange(level.value, level.value),
            handler
        );
    }

    public void addMapping(Level minLevel, Level maxLevel, shared LogHandler handler) {
        this.mappings ~= Mapping(
            LevelRange(minLevel.value, maxLevel.value),
            handler
        );
    }

    shared void handle(LogMessage msg) {
        foreach (mapping; mappings) {
            if (msg.level.value >= mapping.range.minLevel && msg.level.value <= mapping.range.maxLevel) {
                mapping.handler.handle(msg);
            }
        }
    }
}