/** 
 * The handler module defines the `LogHandler` interface, as well as several
 * simple handler implementations that can be used or extended by SLF4D
 * implementations.
 */
module slf4d.handler;

import slf4d.logger;

/** 
 * The interface for any component that consumes log messages generated by a
 * `Logger`. Only messages whose level is greater than or equal to the logger's
 * level will be sent to handlers. For example, a Logger configured at an INFO
 * log level will send INFO, WARN, and ERROR messages, but not DEBUG or TRACE.
 *
 * Each Logger has a single root LogHandler instance. This "root handler" can
 * be a very simple handler that sends messages to stdout, or it could be a
 * more complex composition of handlers to distribute logs to various locations
 * according to filtering logic.
 *
 * Note that the handler is `shared`. One handler instance exists and is used
 * by all application threads.
 */
shared interface LogHandler {
    /** 
     * Handles a log message.
     * Params:
     *   msg = The log message that was generated.
     */
    shared void handle(LogMessage msg);
}

/** 
 * A log handler that simply appends all messages it receives to an internal
 * array. This can be useful for testing.
 */
class CachingLogHandler : LogHandler {
    public shared LogMessage[] messages;

    public shared void handle(LogMessage msg) {
        this.messages ~= msg;
    }
}

unittest {
    auto handler = new shared CachingLogHandler();
    Logger logger = Logger(handler);
    assert(handler.messages.length == 0);
    logger.info("Hello world!");
    assert(handler.messages.length == 1);
}

/** 
 * A very primitive log handler that writes messages to stdout. The exact
 * format is undefined, and this handler should **not** be used in production
 * applications.
 */
class StdoutLogHandler : LogHandler {
    import std.stdio;

    shared void handle(LogMessage msg) {
        writefln!"[logger=%s, module=%s, func=%s level=%s] %s: %s"(
            msg.loggerName,
            msg.sourceContext.moduleName,
            msg.sourceContext.functionName,
            msg.level.name,
            msg.timestamp.toISOExtString(),
            msg.message
        );
    }
}

/** 
 * A log handler that simply passes any log message it receives to a list of
 * other handlers.
 */
class MultiLogHandler : LogHandler {
    private shared LogHandler[] handlers;

    public shared this(shared LogHandler[] handlers) {
        this.handlers = handlers;
    }

    shared void handle(LogMessage msg) {
        foreach (handler; handlers) {
            handler.handle(msg);
        }
    }
}

unittest {
    auto h1 = new shared CachingLogHandler();
    auto h2 = new shared CachingLogHandler();
    auto multiHandler = new shared MultiLogHandler([h1, h2]);
    Logger logger = Logger(multiHandler);
    logger.info("Hello world!");
    assert(h1.messages.length == 1);
    assert(h2.messages.length == 1);
}

/** 
 * A handler that applies a filter to log messages, and only passes messages to
 * its internal handler if the filter returns `true`.
 */
class FilterLogHandler : LogHandler {
    private bool function (LogMessage) filterFunction;
    private shared LogHandler handler;

    public shared this(shared LogHandler handler, bool function (LogMessage) filterFunction) {
        this.handler = handler;
        this.filterFunction = filterFunction;
    }

    shared void handle(LogMessage msg) {
        if (this.filterFunction(msg)) {
            this.handler.handle(msg);
        }
    }
}

unittest {
    auto baseHandler = new shared CachingLogHandler();
    auto filterHandler = new shared FilterLogHandler(
        baseHandler,
        (msg) {
            return msg.message.length > 10;
        }
    );
    Logger logger = Logger(filterHandler);
    logger.info("Testing");
    assert(baseHandler.messages.length == 0);
    logger.info("This is a long string!");
    assert(baseHandler.messages.length == 1);
}